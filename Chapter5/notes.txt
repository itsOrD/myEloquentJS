"There are two ways of constructing a softwar design: One way is to make it so simple that there are obviously no deficiencies,
 and the other way is to make it so complicated that there are no obvious deficiencies."
  -C.A.R Hoare, (1980 ACM Turing Award lecture)

pg 84.
Abstract...
  'It is a useful skill, in programming, to notice when you are working at too low a level of abstraction."

pg 86.
Higher Order Functions
  'Higher-order functions allow us to abstract over actions, not just vlaues'

  Weird (to me) example:
	function noisy(f) {
		return (...args) => {
			console.log('Calling with', args);
			let result = f(...args);
			console.log('called with', args, ', returned', result);
			return result;
		};
	}
	// here's the werid bit
	noisy(Math.min)(1, 2, 3)) // <-- two paren'd args..?

  control-flow function!
	function unless(test, then) {
		if (!test) then();
	}

	repeat (3, n => {
		unless(n % 2 === 1, ()> {
			console.log(n, 'is even');
		})
	})

pg 88.
Filter Array breakdown:
  function filter(array, test) {
	  let passed = [];
	  for (let element of array) {
		  // so what is 'test'?
		  if (test(element)) {
			  passed.push(element);
		  }
	  }
	  return passed;
  }

  the above filter array ex is normally used just as: filter(array, element => ...test...)

pg 89.
Map
  'The map method transforms an array by applying a function to all of its elements and building[/returning] a NEW array from the returned values.'
  map breakdown:
  function map(array, transform) {
	  let mapped = [];
	  for (let element of array) {
		  mapped.push(transform(element));
	  }
	  return mapped;
  }
  aka --> let rtlScripts = SCRIPTS.filter(s => s.direction == "rtl");


Reduce
  Summarizing with Reduce [sometimes called 'fold']
    aka...compute a single value from them
	(an example actually is to FIND 'the script with the most characters')  <-- this is the counter-intuitive part about its name to me
	- repeatedly takes a single element from the arr and combines it wiht the running value
	- need a combining fxn and and an array
	- start value can just default to first element of given array
	breakdown: 
	function reduce(array, combine, start) {
		let current = start;
		for (let element of array) {
			current = combine(current, element);
		}
		return current;
	}
	aka --> reduce([1, 2, 3], (a, b) => a + b, 0)); // -> 6

	why is this useful? well if you're clever you can make the 'combine' function do more interesting stuff:
	funciton characterCount(script) {
						// note the destructuring of parameter list
		return script.ranges.reduce((count, [from, to]) => {
			return count + (to - from);
		}, 0);
	}
	SCRIPTS.reduce((a, b) => {
		return characterCount(a) < characterCount(b) ? b : a;
	})


Composability-ness
pg 90.
	HOF shine when you need to compose operations
	ex:
	avg(array) => array.reduce((a, b) => a + b) / array.length;
	console.log(Math.round(average(
		SCRIPTS.filter(s => s.living).map(s => s.year)
	)))
	console.log(Math.round(average(
			SCRIPTS.filter(s => !s.living).map(s => s.year)
	)))


pg 92.
Javascript srings are encoded as a sequence of 16-bit numbers  <-- 'code unites'
A unicode character code was supposed to fit within that limit
65,000 characters was too limiting so... UTF-16 is used by js to identify most commom chars using a single 16-bit code unit, 
...but uses a pair of two such units for others
	'meaning that built-in functions are sometimes looking at the code unit and not the character code (think of emoji and charCodeAt or .length
		''for-of loops can handle the diff btwn code units and character codes just fine b/c they were more recently added)
	'you can also use codePointAt90) to get the code of a character


pg 93/94
function countBy(items, groupName) j{
	let counts = [];
	for (let item of items) {
		let name = groupName(item);
		let known = counts.findIndex(c => c.name == name);
		if (known == -1) {
			counts.push({name, count: 1});
		} else {
			counts[known].count++;
		}
	}
	return counts;
}

function textScripts(text) {
	let scripts = countBy(text, char => {
		let script = characterScript)char.codePointAt(0));
		return script ? script.name : "none";
	}).filter(({name}) => name != "none");

	let total = scripts.reduce((n, {count}) => n + count, 0);
	if (total == 0) return "No scripts found";

	return scripts.map(({name, count}) => {
		return `${Math.round(count * 100 / total)}% ${name}`;
	}).join(", ");
}
